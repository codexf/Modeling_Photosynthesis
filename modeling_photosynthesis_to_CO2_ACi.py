# -*- coding: utf-8 -*-
"""Created on 2020-06-16 A python script for fitting carbon dioxide response curves (A-Ci) generated by the LI-6800
portable photosynthesis systems. The biochemical model of photosynthetic CO2 assimilation is based on Busch et al.,
2018 (https://doi.org/10.1038/s41477-017-0065-x)

@author: XF
"""
# Python 3.8
# V 1.0

# Import libraries needed for fitting the A/Ci Curve
import glob
import os
import matplotlib.pyplot as plt
import pandas as pd
import numpy as np

# Import curve fitting package from scipy
from scipy.optimize import least_squares


class Model:
    def __init__(self, O, Sco, Kc, Ko, Rl, gm, TPstart):
        """
        constructor
        :param O: Oxygen partial pressure (Pa)
        :param Sco: Rubisco Specificity on a Pa/Pa basis 
        :param Kc: Michaelis-Menten coefficent Km for rubisco carboxylation (Pa)
        :param Ko: Michaelis-Menten coefficent Km for rubisco oxygenation (Pa)
        :param Rl: Non-photorespiratory CO2 release (umol m-2 s-1)
        :param gm: Mesophyll conductance
        :param TPstart: When Cc is below the value of TPstart (Pa), infinite y-values will be inserted in the method
        """
        self.O = O
        self.Sco = Sco
        self.Kc = Kc
        self.Ko = Ko
        self.Rl = Rl
        self.gm = gm
        self.TPstart = TPstart

    def calc_Cc(self, df):
        """
        calculates the CO2 partial pressure in the chloroplast (Cc) 
        
        :param df: a pandas dataframe containing columns of [CO2 assimilation rate 'A' (umol m-2 s-1)] and
            [Intercellular CO2 'Pci' (Pa)] or just containing the column [Chloroplastic CO2 'Cc' (Pa)]
        :return Cc: numpy array, a CO2 partial pressure in the chloroplast (Pa)
        """
        if set(['Pci', 'A']).issubset(df.columns):
            Cc = np.array(df['Pci'] - df['A'] / self.gm)
        elif 'Cc' in df.columns:
            Cc = np.array(df['Cc'])
        else:
            raise Exception("Your dataframe does not have columns 'Pci' and 'A', nor does it has the column 'Cc' \n")
        return Cc

    def calc_gamma(self):
        """
        calculates gamma star for the original FvCB model, assuming
        photorespiration is a fully closed pathway and 0.5 moles of CO2
        are released for every mole of oxygenation reactions.
        :return gamma: float, chloroplastic CO2 compensation point in the absence of mitochondrial respiration (Pa)
       """
        gamma = 0.5 * self.O / self.Sco
        return gamma

    def calc_gammaG(self, aG):
        """
        calculates gamma star for the Busch nitrogen model (eq 12, Busch et al., 2018),
        adjusted for the proportion of glycine removed from photorespiration
        :param aG: float, proportion of glycolate that leaves as glycine
        :return gammaG: float, chloroplastic CO2 compensation point in the absence of
                mitochondrial respiration adjusted for glycine loss (Pa)
        """
        gammaG = 0.5 * (1 - aG) * self.O / self.Sco
        return gammaG

    def calc_Wc(self, df, Vcmax):
        """
        calculates rubisco limited carboxylation rate
        :param df: a pandas dataframe containing columns of [CO2 assimilation rate 'A' (umol m-2 s-1)] and
            [Intercellular CO2 'Pci' (Pa)] or just containing the column [Chloroplastic CO2 'Cc' (Pa)]
        :param Vcmax: float, the maximal rubisco carboxylation rate (umol m-2 s-1)
        :return Wc: float, rubisco-limited carboxylation rate (umol m-2 s-1)
        """
        Cc = self.calc_Cc(df)
        Wc = Vcmax * Cc / (Cc + self.Kc * (1 + self.O / self.Ko))  # (eq 6, Busch et al., 2018)
        return Wc

    def calc_Wj(self, df, J, aG, aS):
        """
        calculates RuBP regeneration limited carboxylation rate
        :param df: a pandas dataframe containing columns of [CO2 assimilation rate 'A' (umol m-2 s-1)] and
            [Intercellular CO2 'Pci' (Pa)] or just containing the column [Chloroplastic CO2 'Cc' (Pa)]
        :param J: float, the maximum rate of electron transport (umol m-2 s-1)
        :param aG: float, proportion of glycolate that leaves as glycine
        :param aS: float, proportion of glycolate that leaves as serine
        :return Wj: float, RuBP regeneration limited carboxylation rate (umol m-2 s-1)
        """
        Cc = self.calc_Cc(df)
        phi = 2 * self.calc_gamma() / Cc
        Wj = J / (4 + (4 + 8 * aG + 4 * aS) * phi)
        return Wj

    def calc_Wp(self, df, Tp, aG, aS):
        """
        calculates triose-phosphate limited carboxylation rate 
        :param df: a pandas dataframe containing columns of [CO2 assimilation rate 'A' (umol m-2 s-1)] and
            [Intercellular CO2 'Pci' (Pa)] or just containing the column [Chloroplastic CO2 'Cc' (Pa)]
        :param Tp: float, the rate of triose phosphate export from the chloroplast (umol m-2 s-1)
        :param aG: float, proportion of glycolate that leaves as glycine
        :param aS: float, proportion of glycolate that leaves as serine
        :return Wp: float, triose-phosphate limited carboxylation rate (umol m-2 s-1)
        """
        Cc = self.calc_Cc(df)
        phi = 2 * self.calc_gamma() / Cc
        Wp = 3 * Tp / (1 - 0.5 * (1 + 3 * aG + 4 * aS) * phi)
        return Wp

    def calc_Ac(self, df, Vcmax, aG):
        """
        calculates RuBP regeneration limited assimilation rate
        :param df: a pandas dataframe containing columns of [CO2 assimilation rate 'A' (umol m-2 s-1)] and
            [Intercellular CO2 'Pci' (Pa)] or just containing the column [Chloroplastic CO2 'Cc' (Pa)]
        :param Vcmax: float, the maximal rubisco carboxylation rate (umol m-2 s-1)
        :param aG: float, proportion of glycolate that leaves as glycine
        :return Ac: float, rubisco-limited photosynthetic rate (umol m-2 s-1)
        """
        Cc = self.calc_Cc(df)
        gammaG = self.calc_gammaG(aG)
        coef = 1 - gammaG / Cc
        Wc = self.calc_Wc(df, Vcmax)
        Ac = Wc * coef - self.Rl  # (eq 11, Busch et al., 2018)
        return Ac

    def calc_Aj(self, df, J, aG, aS):
        """
        calculates RuBP regeneration limited assimilation rate
        :param df: a pandas dataframe containing columns of [CO2 assimilation rate 'A' (umol m-2 s-1)] and
            [Intercellular CO2 'Pci' (Pa)] or just containing the column [Chloroplastic CO2 'Cc' (Pa)]
        :param J: float, the maximum rate of electron transport (umol m-2 s-1)
        :param aG: float, proportion of glycolate that leaves as glycine
        :param aS: float, proportion of glycolate that leaves as serine
        :return Aj: float, RuBP regeneration limited assimilation rate (umol m-2 s-1)
        """
        Cc = self.calc_Cc(df)
        gammaG = self.calc_gammaG(aG)
        coef = 1 - gammaG / Cc
        Wj = self.calc_Wj(df, J, aG, aS)
        Aj = Wj * coef - self.Rl  # (eq 11, Busch et al., 2018)
        return Aj

    def calc_Ap(self, df, Tp, aG, aS):
        """
        calculates triose-phosphate limited assimilation rate
        Insert infinite y-values when the x-value (Cc) is lower than the defined TPstart (Pa)
        :param df: a pandas dataframe containing columns of [CO2 assimilation rate 'A' (umol m-2 s-1)] and
            [Intercellular CO2 'Pci' (Pa)] or just containing the column [Chloroplastic CO2 'Cc' (Pa)]
        :param Tp: float, the rate of triose phosphate export from the chloroplast (umol m-2 s-1)
        :param aG: float, proportion of glycolate that leaves as glycine
        :param aS: float, proportion of glycolate that leaves as serine
        :return Ap: float, triose-phosphate limited assimilation rate (umol m-2 s-1)
        """
        Cc = self.calc_Cc(df)
        gammaG = self.calc_gammaG(aG)
        coef = 1 - gammaG / Cc
        Wp = self.calc_Wp(df, Tp, aG, aS)
        Ap = Wp * coef - self.Rl  # (eq 11, Busch et al., 2018)
        # Insert infinite y-values when the x-value (Cc) is low
        Ap[np.where(Cc < self.TPstart)[0]] = np.inf
        return Ap

    def calc_A(self, df, Vcmax, J, Tp, aG, aS):
        '''
        calculates the minimum of the three rates Ac, Aj and Ap, which are the assimilation rates that
        supported under a Rubisco, electron transport or TPU limitation, respectively, assuming the Busch nitrogen model
        :param df: a pandas dataframe containing columns of [CO2 assimilation rate 'A' (umol m-2 s-1)] and
            [Intercellular CO2 'Pci' (Pa)] or just containing the column [Chloroplastic CO2 'Cc' (Pa)]
        :param Vcmax: float, the maximal rubisco carboxylation rate (umol m-2 s-1)
        :param J: float, the maximum rate of electron transport (umol m-2 s-1)
        :param Tp: float, the rate of triose phosphate export from the chloroplast (umol m-2 s-1)
        :return A: float, the minimum assimilation rate of the three limited scenarios (umol m-2 s-1)
        '''
        Ac = self.calc_Ac(df, Vcmax, aG)
        Aj = self.calc_Aj(df, J, aG, aS)
        Ap = self.calc_Ap(df, Tp, aG, aS)
        A = np.minimum(Ac, np.minimum(Aj, Ap))
        return A

    def fit_Aci(self, df, plot):
        """
        fits the measured data to estimate parameters (Vcmax, J, Tp, aG, aS) in the Busch nitrogen model
        :param df: a pandas dataframe containing columns of [CO2 assimilation rate 'A' (umol m-2 s-1)] and
            [Intercellular CO2 'Pci' (Pa)] or just containing the column [Chloroplastic CO2 'Cc' (Pa)]
        :param plot: boolean, whether you want to make a plot
        :return:
        f: if plot = True, return the plot object of the measured A-Cc data, the three biochemical limitation curves,
        and a fitted curve;
        df_fits: if plot = False, return the dataframe with fitting parameters
        """
        # lower and upper bounds on six parameters (Vcmax, J, Tp, 0<aGmax<1, 0<aSmax<0.75, Nmax)
        # haven't incorporate 0≤ aGmax + (4/3)*aSmax ≤1
        bounds = ([0, 0, 0, 0.01, 0.01], [500, 500, 20, 1, 0.75])
        # initial guess parameters for Vcmax, J, Tp, aG, aS
        p0 = [80, 130, 5, 0.1, 0.4]

        # The function calculates the residuals
        def resid_func(args):
            return self.calc_A(df, *args) - df["A"]

        # least squares of the resid_func function is stored in "result"
        result = least_squares(resid_func, x0=p0, bounds=bounds)

        [Vcmax, J, Tp, aG, aS] = result.x  # Assign multiple variables with list values using list comprehension

        residuals = resid_func(result.x)

        SSR = sum(np.square(residuals))  # residual sum of squares

        if 'Cc' not in df.columns:
            df['Cc'] = self.calc_Cc(df)  # add a column 'Cc' if there isn't one in the df

        df = df.sort_values("Cc")

        if plot:
            f = plt.figure()  # A plot is generated
            plt.scatter(df['Cc'], df['A'], label='data', color='black')  # plot the raw data
            plt.plot(df['Cc'], self.calc_Ac(df, Vcmax, aG), color='orange', label='rubisco',
                     linestyle=':')  # plot the fitted Ac curve
            plt.plot(df['Cc'], self.calc_Aj(df, J, aG, aS), color='blue', label='RuBP',
                     linestyle=':')  # plot the fitted Aj curve
            plt.plot(df['Cc'], self.calc_Ap(df, Tp, aG, aS), color='green', label="TPU",
                     linestyle=':')  # plot the fitted Ap curve
            plt.plot(df['Cc'], self.calc_A(df, Vcmax, J, Tp, aG, aS), label='fit curve',
                     color='gray')  # plot the fitted A curve
            # plt.suptitle('A-Cc Curve Fitting', fontsize=12, fontweight="bold")
            plt.title(
                f'SSR={SSR:.0f}, Vcmax={Vcmax:.0f}, J={J:.0f}, Tp={Tp:.0f}, aG={aG:.2f}, aS={aS:.2f}',
                fontsize=11, color='darkblue')  # Gives the plot a title
            plt.xlabel('Cc (Pa)')  # Labels the x-axis
            plt.ylabel('A (\u03BCmol $\mathregular{CO_2 \ m^{-2} \ s^{-1})}$')  # Labels the y-axis
            plt.legend(frameon=False, loc='lower right')  # Create a legend
            plt.ylim(-2, 25)  # Set y-axis limits
            return f

        else:
            # print(f'SSR={SSR:.2f}, Vcmax={Vcmax:.2f}, J={J:.2f}, Tp={Tp:.2f}, aG={aG:.2f}, aS={aS:.2f}')
            df_fits = pd.DataFrame({'SSR': SSR, 'Vcmax': Vcmax, 'J': J, 'Tp': Tp, 'aG': aG, 'aS': aS}, index=[0])
            return df_fits


def main():
    # 1. Define parameters
    O = 21210
    Sco = 2622  # assuming gamma* = 4.044 at 21% O2 (O=21210)
    Kc = 27.24
    Ko = 16582
    gm = 2.001
    Rl = 0.63
    TPstart = 30

    # 2. Create a model object for 21% O2
    model_21O = Model(O=O, Sco=Sco, Kc=Kc, Ko=Ko, Rl=Rl, gm=gm, TPstart=TPstart)

    # 3. Define the file path of the LI-6800 csv files
    script_path = os.path.split(os.path.realpath(__file__))[0]  # get the absolute path in where this script resides
    data_path = script_path + os.path.sep + 'data_ACi'
    print('data path:', data_path)

    output_path = script_path + os.path.sep + 'output_ACi'
    if not os.path.exists(output_path):
        os.mkdir(output_path)  # make a new folder for output files
    print('ouptut path:', output_path)

    # 4. Read in and merge all the csv files, fit the data in each file with plot, and merge all fitting parameters
    files = glob.glob(os.path.join(data_path, "*.csv"))
    all_df = []  # dataframe for all data files
    all_fits = []  # dataframe for all fitting parameters
    for f in files:  # loop through all csv files in the path
        # clean up individual files and append to the all_df dataframe
        oxygen = pd.read_csv(f, encoding='unicode_escape', nrows=1)['Oxygen'][0]  # extract the oxygen condition used
        df = pd.read_csv(f, encoding='unicode_escape',
                         skiprows=[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 14])  # skip unnecessary rows
        file_name = f.split(os.path.sep)[-1].split('.')[0]  # extract the file name
        df['file_name'] = file_name  # add a column named file_name
        df['oxygen'] = oxygen  # add a column named oxygen
        df = df[['file_name', 'oxygen', 'A', 'Pci']].iloc[1:17]  # select required columns and rows
        df['index'] = df.reset_index().index  # add a column named index
        all_df.append(df.copy(deep=True))  # append the copy df to the all_df dataframe

        # plot the measured A-Cc data, the three biochemical limitation curves, and a fitted curve
        figure = model_21O.fit_Aci(df, plot=True)
        figure.savefig(output_path + os.path.sep + f'figure_Aci_fitting_{file_name}.png', dpi=600)
        print(f'Saving plot for {file_name} to the output path')

        # append the individual fit parameters to the all_fits dataframe
        fits = model_21O.fit_Aci(df, plot=False)
        fits['file_name'] = file_name  # add a column named file_name
        all_fits.append(fits.copy(deep=True))

    # 5. Summarize fitting parameters of all files
    merged_fits = pd.concat(all_fits, ignore_index=True)
    merged_fits = merged_fits.set_index('file_name')
    merged_fits.loc['mean'] = merged_fits.mean()
    merged_fits.loc['std'] = merged_fits.std()
    merged_fits.loc['sem'] = merged_fits.sem()
    merged_fits.to_csv(output_path + os.path.sep + 'table_ACi_fitting.csv')
    print('Saving summary table of fitting parameters to the output path')

    # 6. Compute Cc and get summary statistics for A and Cc across all replicates
    merged_df = pd.concat(all_df, ignore_index=True)
    df_21O = merged_df.assign(Cc=lambda x: x['Pci'] - x['A'] / gm)
    summary_A_21O = df_21O.groupby(['index']).agg({'A': ['mean', 'std', 'sem']})
    summary_Pci_21O = df_21O.groupby(['index']).agg({'Cc': ['mean', 'std', 'sem']})
    result_21O = pd.concat([summary_A_21O, summary_Pci_21O], axis=1).reset_index()
    result_21O.columns = ["_".join(x) for x in result_21O.columns.ravel()]
    # print(result_21O)

    # 7. Plot measured mean +- sd with the fitted curves 
    # Simulate data with Vcmax, J, Tp, aG, aS from mean of individual fitted parameters
    mean_fits = merged_fits.loc['mean'].copy(deep=True)
    SSR, Vcmax, J, Tp, aG, aS = mean_fits.tolist()
    sim_data = {'Cc': np.linspace(0.1, 200, num=50)}
    df_sim_data = pd.DataFrame(data=sim_data)  # similated data

    plt.figure()  # A plot is generated
    plt.errorbar(result_21O['Cc_mean'], result_21O['A_mean'], yerr=result_21O['A_std'],
                 fmt='o', markersize=4, capsize=3, color="black", label="Data");
    plt.plot(df_sim_data['Cc'], model_21O.calc_Ac(df_sim_data, Vcmax, aG), color='orange',
             label='Rubisco')  # plot the fitted Ac curve
    plt.plot(df_sim_data['Cc'], model_21O.calc_Aj(df_sim_data, J, aG, aS), color='blue',
             label='RuBP')  # plot the fitted Aj curve
    plt.plot(df_sim_data['Cc'], model_21O.calc_Ap(df_sim_data, Tp, aG, aS), color='green',
             label="TPU")  # plot the fitted Ap curve
    plt.xlabel('Cc (Pa)')  # Labels the x-axis
    plt.ylabel('A (\u03BCmol $\mathregular{CO_2 \ m^{-2} \ s^{-1})}$')  # Labels the y-axis
    plt.legend(frameon=False, loc='lower right')  # Create a legend
    plt.xlim(-2, 135)  # Set x-axis limits
    plt.ylim(-2, 25)  # Set y-axis limits
    plt.savefig(output_path + os.path.sep + "figure_ACi_fitting_mean_sd.png", dpi=600)
    print('Saving the plot for measured msd and fitted curves to the output path')


if __name__ == '__main__':
    main()
